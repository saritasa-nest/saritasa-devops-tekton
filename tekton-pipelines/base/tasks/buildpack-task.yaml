apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: buildpack
spec:
  description: >-
    The Buildpacks task builds source into a container image and pushes it to a AWS ECR registry,
    using Cloud Native Buildpacks.

  workspaces:
    - name: source

  resources:
    inputs:
      - name: app
        type: git
    outputs:
      - name: image
        type: image

  params:
    - name: application
      description: The name of the application being built
    - name: builder_image
      description: The image on which builds will run (must include lifecycle and compatible buildpacks).
    - name: cache
      description: The name of the persistent app cache volume.
      default: empty-dir
    - name: cache_image
      description: The name of the persistent app cache image.
      default: ""
    - name: platform_dir
      description: The name of the platform directory.
      default: empty-dir
    - name: user_id
      description: The user ID of the builder image user.
      default: "1000"
    - name: group_id
      description: The group ID of the builder image user.
      default: "1000"
    - name: process_type
      description: The default process type to set on the image.
      default: "web"
    - name: source_subpath
      description: A subpath within the `source` input where the source to build is located.
      default: ""
    - name: skip_restore
      description: Do not write layer metadata or restore cached layers
      default: "false"
    - name: run_image
      description: Reference to a run image to use
      default: ""
    - name: docker_registry
      description: "AWS Private ecr registry address"
    - name: environment

  stepTemplate:
    env:
      - name: CNB_PLATFORM_API
        value: "0.4"
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config # project specific values

  steps:
    - name: prepare
      # Latest alpine as of Oct 22, 2020
      image: docker.io/library/bash:5.1.4@sha256:b208215a4655538be652b2769d82e576bc4d0a2bb132144c060efc5be8c3f5d6
      imagePullPolicy: Always
      script: |
          #!/usr/bin/env bash
          set -e

          chown -R "$(params.user_id):$(params.group_id)" "/tekton/home" &&
          chown -R "$(params.user_id):$(params.group_id)" "/layers" &&
          chown -R "$(params.user_id):$(params.group_id)" "/cache" &&
          chown -R "$(params.user_id):$(params.group_id)" "$(workspaces.source.path)"
          chown -R "$(params.user_id):$(params.group_id)" "$(resources.inputs.app.path)"

      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.cache)
          mountPath: /cache
      securityContext:
        privileged: true
    
    # I dislike this hack 
    # https://github.com/tektoncd/catalog/blob/main/task/buildpacks/0.3/buildpacks.yaml#L68-L113
    # but we should use it until this is resolved:
    # - https://github.com/buildpacks/tekton-integration/issues/33
    # - https://github.com/buildpacks/tekton-integration/issues/32
    # TODO: check in the future and adjust when project.toml is clear to be supported.
  
    - name: set-env-vars
      image: docker.io/library/bash:5.1.4@sha256:b208215a4655538be652b2769d82e576bc4d0a2bb132144c060efc5be8c3f5d6
      script: |
       #!/usr/bin/env bash
       set -e

       ENV_DIR=/platform/env
       ENV_VARS=(`env`)
       
       function save_var() {
         key=`echo $1 | awk -F= '{print $1}'`
         val=`echo $1 | awk -F= '{print $2}'`
         echo "--> Exporting env var $1"
         echo -n $val > $ENV_DIR/$key 
       }
       
       echo "--> Creating 'env' directory: $ENV_DIR"
       mkdir -p $ENV_DIR
       
       for VAR in "${ENV_VARS[@]}"
       do
          # process google env vars as defined in here
          # https://github.com/GoogleCloudPlatform/buildpacks
          # https://github.com/GoogleCloudPlatform/buildpacks#language-idiomatic-configuration-options
          # FIXME: Some of the buildpacks rely on `PATH` env variable, but it overlaps with in-bash PATH env var
          # so implementation for PATH should be different, probably via BUILDPACK_PATH value that we store in build-pipeline-config 
          # and then if that value is found - store it in /platform/env folder as a workaround. It's too bad project.toml is not working
          # as intented.
          # 
          case $VAR in
             # google buildpacks
             # ----------------------------
             "GOOGLE_"*|"GO"*|"MAVEN_"*|"GRADDLE_"*|"NPM_"*|"COMPOSER_"*|"PIP_"*|"BUNDLE_"*)
               save_var $VAR
             ;;
             
             # paketo buildpacks
             # ----------------------------
             "BP_"*)
               save_var $VAR
             ;;

             # paketo dotnet buildpacks
             # ----------------------------
             "DOTNET"*|"RUNTIME_VERSION"*|"SDK_LOCATION"*)
               save_var $VAR
             ;;
             
             # paketo go buildpacks
             # ----------------------------
             "DEPCACHEDIR"*)
               save_var $VAR
             ;;
             
             # paketo nodejs buildpacks
             # ----------------------------
             "NODE_"*|"MEMORY_"*)
               save_var $VAR
             ;;
       
             # paketo php buildpacks
             # ----------------------------
             "APP_"*|"SERVER_"*|"MIBDIRS"*|"PHP_"*)
               save_var $VAR
             ;;
             # paketo ruby buildpacks
             # ----------------------------
             "GEM_"*|"BUNDLE_"*)
               save_var $VAR
             ;;   
          esac
       done
      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.platform_dir)
          mountPath: /platform
      securityContext:
        privileged: true

    - name: python
      image: docker.io/library/bash:5.1.4@sha256:b208215a4655538be652b2769d82e576bc4d0a2bb132144c060efc5be8c3f5d6
      script: |
        #!/usr/bin/env bash
        set -e

        APP=$(resources.inputs.app.path)

        # python related
        # we should have a requirements.txt file in the build folder for our buildpack to work correctly
        # as a result we just copy it.
        if [ -f $APP/manage.py ]; then
          case $(params.environment) in

            dev|develop|development)
              [ -f $APP/requirements/dev.txt ]         && cp $APP/requirements/dev.txt $APP/requirements.txt
              [ -f $APP/requirements/develop.txt ]     && cp $APP/requirements/develop.txt $APP/requirements.txt
              [ -f $APP/requirements/development.txt ] && cp $APP/requirements/development.txt $APP/requirements.txt
              ;;
            staging)
              [ -f $APP/requirements/staging.txt ]     && cp $APP/requirements/staging.txt $APP/requirements.txt
              ;;
            prod|production)
              [ -f $APP/requirements/prod.txt ]        && cp $APP/requirements/prod.txt $APP/requirements.txt
              [ -f $APP/requirements/production.txt ]  && cp $APP/requirements/production.txt $APP/requirements.txt
              ;;
            *)
              cp $APP/requirements/$(params.environment).txt $APP/requirements.txt
              ;;
          esac

          [ -f $APP/requirements.txt ] && echo "Found requirements.txt" || exit 1
        fi

    - name: nodejs
      image: node:14
      script: |
        #!/bin/bash
        set -e

        APP=$(resources.inputs.app.path)

        if [ -f $APP/package.json ]; then
          cd $APP
          yes | npm install --silent
          npm run build:$(params.environment) || echo "unable to build  $(params.environment)"
          rm -rf node_modules && echo "remove node_modules dir"
        fi
      securityContext:
        privileged: true

    - name: php
      image: docker.io/library/bash:5.1.4@sha256:b208215a4655538be652b2769d82e576bc4d0a2bb132144c060efc5be8c3f5d6
      script: |
        #!/usr/bin/env bash
        set -e

        APP=$(resources.inputs.app.path)

        # php related
        # Workaround to fix no PHP detection, when package.json presents

        if [[ -f $APP/composer.json && -f $APP/package.json ]]; then
          rm -f $APP/package.json
          ls -la $APP
        fi

    # if you need to debug this step you can do:
    # k exec -ti `k --no-headers=true get pods -l tekton.dev/task=buildpack | awk '{print $1}'` -c step-create bash
    - name: build
      image: $(params.builder_image)
      imagePullPolicy: Always
      script: |
        #!/bin/bash

        aws ecr get-login-password --region $AWS_REGION | docker login -u AWS --password-stdin $(params.docker_registry)

        # build image utilizing backpack
        /cnb/lifecycle/creator \
          -app=/workspace/app/$(params.source_subpath) \
          -project-metadata=/workspace/app/project.toml \
          -cache-dir=/cache \
          -layers=/layers \
          -platform=/platform \
          -report=/layers/report.toml \
          -cache-image=$(params.cache_image) \
          -uid=$(params.user_id) \
          -gid=$(params.group_id) \
          -process-type=$(params.process_type) \
          -skip-restore=$(params.skip_restore) \
          -previous-image=$(resources.outputs.image.url) \
          -run-image=$(params.run_image) \
          $(resources.outputs.image.url)

      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.cache)
          mountPath: /cache
        - name: $(params.platform_dir)
          mountPath: /platform
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
  volumes:
    - name: empty-dir
      emptyDir: {}
    - name: layers-dir
      emptyDir: {}
