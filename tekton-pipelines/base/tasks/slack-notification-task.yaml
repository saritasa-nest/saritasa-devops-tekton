apiVersion: tekton.dev/v1beta1
kind: Task
metadata:     
  name: slack-notification
spec:
  description: >-
    Send slack notification with various information about pipeline progress/result.
    You can see my question about dealing with task status here: https://github.com/tektoncd/pipeline/issues/3762

  workspaces:
    - name: source

  params:
    - name: application
    - name: sha
    - name: head_commit
    - name: head_commit_message
    - name: pusher_name
    - name: pusher_email
    - name: pusher_avatar
    - name: pusher_url
    - name: repository_url
    - name: environment
    - name: branch
    - name: status
    - name: pipelinerun_name
      default: "reserved"

  stepTemplate:
    envFrom:
      - configMapRef:
          name: $(params.application)-build-pipeline-config
      - secretRef:
          name: $(params.application)-slack-secret  # used for webhook URL, channel_id
      - secretRef:
          name: slack-api-token-secret  # used for slack api token (common for all projects)

    env:
      - name: POD_NAME
        valueFrom:
          fieldRef:
            fieldPath: metadata.name
    volumeMounts:
      - name: podinfo
        mountPath: /etc/podinfo

  steps:
    - name: get-thread-msg
      image: saritasallc/python3:0.2
      script: |
        #!/usr/bin/env python3
        import os, sys
        from slack_sdk import WebClient

        msg_text = "Tekton CI notifications"
        env_dir = "$(workspaces.source.path)/env"
        token = os.environ.get("SLACK_API_TOKEN")
        channel_id = os.environ.get("SLACK_CHANNEL_ID")

        if not token or not channel_id:
          quit()

        try:
          client = WebClient(token=token)
          response = client.pins_list(channel=channel_id).data
        except SlackApiError as e:
          # if there is no pinned message - do nothing and slack notification
          # would be printed in channel
          print(
            f"Not able to get pinned deployment message\nTraceback: {e}",
            file=sys.stdout
          )

        pinned_messages = list(filter(
          lambda item: msg_text.lower() in item["message"]["text"].lower(),
          sorted(response["items"], key=lambda x: x["created"], reverse=True)
        ))
        deployment_msg = pinned_messages and pinned_messages[0] or dict()
        thread = deployment_msg.get("message", {}).get("ts", "")

        if not os.path.exists(env_dir):
          os.makedirs(env_dir)

        with open(f"{env_dir}/SLACK_THREAD", "w") as f:
          f.write(thread)
          print(
            f"Saved `{thread}` thread in {env_dir}/SLACK_THREAD",
            file=sys.stdout
          )

    - name: notification
      image: cloudposse/slack-notifier:0.4.0
      script: |
        #!/bin/sh
        # tekton injects these labels into pods
        # https://tekton.dev/docs/pipelines/labels/
        # so we can easily extract items
        # podinfo is mounted in TriggerTemplate
        pipelinerun_name=$(awk -F= '/tekton.dev\/pipelineRun/ {gsub(/"/, "", $2);print $2}' /etc/podinfo/labels)
        status="`echo $(params.status) | tr '[:upper:]' '[:lower:]'`"

        echo "result: $status"

        thread_env_file="$(workspaces.source.path)/env/SLACK_THREAD"
        if [ -f $thread_env_file ]; then
          thread=$(cat $thread_env_file)
        fi
        echo "thread: $thread"

        if [ "$status" = "succeeded" ]; then
          color="good"
          thumb_url="$(params.pusher_avatar)"
          text_status="The latest changes to $(params.environment) have been deployed successfully"

        else
          color="danger"
          thumb_url="$SLACK_FAILURE_ICON_URL"
          text_status="The latest changes to $(params.environment) failed to be deployed"
        fi

        argo_app_url="$ARGOCD_SERVER/$ARGOCD_ROOT_PATH/applications/$(params.application)"
        argo_app_url=$(echo $argo_app_url | sed 's/\/\//\//g')
        argo_app_url="https://$argo_app_url"

        slack-notifier \
        -user_name "Tekton" \
        -icon_emoji ":white_check_mark:" \
        -color "$color" \
        -thread "$thread" \
        -author_name "[$(params.application)] by $(params.pusher_name)" \
        -author_link "$(params.pusher_url)" \
        -title "$(params.head_commit_message)" \
        -text "$text_status" \
        -thumb_url "$thumb_url" \
        -field1_title "Open Application" \
        -field1_value "<$APPLICATION_URL|$APPLICATION_URL>" \
        -field1_short false \
        -field2_title "Branch" \
        -field2_value "$(echo $(params.branch) | sed -r 's/\brefs\/\bheads\///g')" \
        -field2_short true \
        -field3_title "Revision" \
        -field3_value "<$(params.repository_url)/commit/$(params.sha)|$(params.sha)>" \
        -field3_short true \
        -field4_title "Manage" \
        -field4_value "<$(params.repository_url)|Github> | <$(params.repository_url)/issues|Issues> | <$JIRA_PROJECT_URL|Jira> | <$TEKTON_URL/$pipelinerun_name|CI> | <$argo_app_url|CD> " \
        -field4_short false
